"""
SQLAlchemy models for the LokDarpan backend.

This module defines the ORM models used by the application.  In addition to
the basic user and content models (User, Author, Post, Alert), it introduces
several tables to support ward-level electoral intelligence.  These new
structures enable fine-grained aggregation of polling station results and the
storage of demographic and derived analytic features for each ward.  When
adding or modifying tables here remember to run a database migration so that
changes are applied consistently across environments.

The additional models defined in this file are:

* PollingStation – master record for each polling station with geospatial
  location and associated ward/assembly/lok sabha information.
* Election – catalog of elections (GHMC, Assembly, Lok Sabha) and cycles.
* ResultPS – results at polling station level for a given election.
* ResultWardAgg – ward-level aggregation of polling station results.
* WardProfile – snapshot of electors, votes cast and last winner by ward.
* WardDemographics – normalized socio-economic indices per ward.
* WardFeatures – derived analytics such as vote differentials and turnout
  volatility per ward.

These tables are designed to be orthogonal to the existing posts/alerts
schema to avoid regressions in current functionality.  See the project
documentation for more details about the meaning of each field.
"""

from datetime import datetime  # kept (harmless if unused)
from flask_login import UserMixin
from sqlalchemy.sql import func
from .extensions import db

class User(UserMixin, db.Model):
    """Basic user account."""

    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(256), nullable=False)

    def __repr__(self) -> str:  # pragma: no cover
        return f"<User {self.username}>"

# at top, alongside other imports
# from flask_login import UserMixin   # already present
# from .extensions import db          # already present

class Epaper(db.Model):
    __tablename__ = "epaper"

    id = db.Column(db.Integer, primary_key=True)
    publication_name = db.Column(db.String(100), nullable=False)
    publication_date = db.Column(db.Date, nullable=False, index=True)
    raw_text = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, index=True)  # server_default optional
    # NOTE: keep nullable=True for now; after backfill+constraint, we can switch to False
    sha256 = db.Column(db.String(64), nullable=False, index=True, unique=True)

class Author(db.Model):
    """Content author for posts; optional party affiliation."""

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(120), unique=True, nullable=False)
    party = db.Column(db.String(64), nullable=True)  # optional party field

    def __repr__(self) -> str:  # pragma: no cover
        return f"<Author {self.name}>"


class Post(db.Model):
    """Ingested post or news item with optional metadata."""

    id = db.Column(db.Integer, primary_key=True)
    text = db.Column(db.Text, nullable=False)
    epaper_id = db.Column(db.Integer, db.ForeignKey('epaper.id'))
    epaper = db.relationship('Epaper', backref='posts')
    author_id = db.Column(db.Integer, db.ForeignKey('author.id'))
    author = db.relationship('Author', backref='posts')
    # The city/ward this post pertains to (e.g. "Jubilee Hills").
    city = db.Column(db.String(120))
    # Emotion detected in the text (e.g. "Positive", "Angry").
    emotion = db.Column(db.String(64))
    # Party associated with the source (optional).
    party = db.Column(db.String(64))
    # Creation timestamp.
    created_at = db.Column(db.DateTime, nullable=False, index=True,
                           default=func.now())

    def __repr__(self) -> str:  # pragma: no cover
        return f"<Post {self.id} city={self.city}>"


class Alert(db.Model):
    """Table for storing strategic alerts and briefings generated by the system."""

    id = db.Column(db.Integer, primary_key=True)
    # Ward identifier or context for the alert (e.g. "Jubilee Hills").
    ward = db.Column(db.String(120), index=True)
    # High level priority message (used by proactive analysis).
    description = db.Column(db.String(512))
    # Severity level for the alert (e.g. "High", "Medium", "Info").
    severity = db.Column(db.String(32))
    # JSON payload of opportunities extracted from analysis.
    opportunities = db.Column(db.Text)
    # JSON payload of threats extracted from analysis.
    threats = db.Column(db.Text)
    # JSON payload of actionable alert items.
    actionable_alerts = db.Column(db.Text)
    # JSON array of article URLs used as evidence.
    source_articles = db.Column(db.Text)
    # Timestamp of creation.
    created_at = db.Column(db.DateTime, nullable=False, index=True,
                           default=func.now())
    # Timestamp of last update.
    updated_at = db.Column(db.DateTime, nullable=False, index=True,
                           default=func.now(), onupdate=func.now())

    def __repr__(self) -> str:  # pragma: no cover
        return f"<Alert {self.ward} severity={self.severity}>"


# ---------------------------------------------------------------------------
# Electoral spine tables
# ---------------------------------------------------------------------------

class PollingStation(db.Model):
    """Master record for each polling station including geolocation and
    administrative mapping to wards, assembly constituencies (AC) and
    parliamentary constituencies (PC).  The ps_id should correspond to the
    official identifier in Form-20 documents.  Lat/lon coordinates are
    optional and can be populated via geocoding during ETL.
    """

    __tablename__ = 'polling_station'

    id = db.Column(db.Integer, primary_key=True)
    ps_id = db.Column(db.String(64), unique=True, nullable=False)
    name = db.Column(db.String(256))
    address = db.Column(db.String(512))
    lat = db.Column(db.Float)
    lon = db.Column(db.Float)
    ac_id = db.Column(db.String(64))
    pc_id = db.Column(db.String(64))
    ward_id = db.Column(db.String(64), index=True)
    ward_name = db.Column(db.String(256))
    source_meta = db.Column(db.JSON)

    def __repr__(self) -> str:  # pragma: no cover
        return f"<PS {self.ps_id} ward={self.ward_id}>"


class Election(db.Model):
    """Catalog of elections (GHMC, ASSEMBLY, LOKSABHA) and cycles."""

    __tablename__ = 'election'

    id = db.Column(db.Integer, primary_key=True)
    # Election type: 'GHMC', 'ASSEMBLY', 'LOKSABHA'
    type = db.Column(db.String(16), nullable=False)
    year = db.Column(db.Integer, nullable=False)
    round = db.Column(db.String(32))
    official_ref = db.Column(db.String(256))  # link or id to official source

    def __repr__(self) -> str:  # pragma: no cover
        return f"<Election {self.type} {self.year}>"


class ResultPS(db.Model):
    """Polling station level election result."""

    __tablename__ = 'result_ps'

    id = db.Column(db.Integer, primary_key=True)
    election_id = db.Column(db.Integer, db.ForeignKey('election.id'), nullable=False)
    ps_id = db.Column(db.String(64), nullable=False)
    party = db.Column(db.String(64), nullable=False)
    candidate = db.Column(db.String(256))
    votes = db.Column(db.Integer)
    total_polled = db.Column(db.Integer)
    rejected = db.Column(db.Integer)
    created_at = db.Column(db.DateTime, nullable=False, default=func.now())

    def __repr__(self) -> str:  # pragma: no cover
        return f"<ResultPS ps_id={self.ps_id} party={self.party} votes={self.votes}>"


class ResultWardAgg(db.Model):
    """Aggregated ward-level election result derived from polling station results."""

    __tablename__ = 'result_ward_agg'

    id = db.Column(db.Integer, primary_key=True)
    election_id = db.Column(db.Integer, db.ForeignKey('election.id'), nullable=False)
    ward_id = db.Column(db.String(64), nullable=False, index=True)
    party = db.Column(db.String(64), nullable=False)
    votes = db.Column(db.Integer)
    vote_share = db.Column(db.Float)  # percentage share within ward
    turnout_pct = db.Column(db.Float)
    computed_at = db.Column(db.DateTime, nullable=False, default=func.now())

    def __repr__(self) -> str:  # pragma: no cover
        return f"<ResultWardAgg ward={self.ward_id} party={self.party}>"


class WardProfile(db.Model):
    """Snapshot of base turnout and last winner information for a ward."""

    __tablename__ = 'ward_profile'

    id = db.Column(db.Integer, primary_key=True)
    ward_id = db.Column(db.String(64), unique=True, nullable=False)
    electors = db.Column(db.Integer)
    votes_cast = db.Column(db.Integer)
    turnout_pct = db.Column(db.Float)
    last_winner_party = db.Column(db.String(64))
    last_winner_year = db.Column(db.Integer)
    updated_at = db.Column(db.DateTime, nullable=False, default=func.now(), onupdate=func.now())

    def __repr__(self) -> str:  # pragma: no cover
        return f"<WardProfile {self.ward_id}>"


class WardDemographics(db.Model):
    """Normalized socio-economic indices per ward."""

    __tablename__ = 'ward_demographics'

    id = db.Column(db.Integer, primary_key=True)
    ward_id = db.Column(db.String(64), unique=True, nullable=False)
    literacy_idx = db.Column(db.Float)
    muslim_idx = db.Column(db.Float)
    scst_idx = db.Column(db.Float)
    secc_deprivation_idx = db.Column(db.Float)
    updated_at = db.Column(db.DateTime, nullable=False, default=func.now(), onupdate=func.now())

    def __repr__(self) -> str:  # pragma: no cover
        return f"<WardDemographics {self.ward_id}>"


class WardFeatures(db.Model):
    """Derived analytics and comparative features for a ward."""

    __tablename__ = 'ward_features'

    id = db.Column(db.Integer, primary_key=True)
    ward_id = db.Column(db.String(64), unique=True, nullable=False)
    # Party share dictionaries keyed by party name (e.g. {"BJP": 0.32, ...}).
    as23_party_shares = db.Column(db.JSON)
    ls24_party_shares = db.Column(db.JSON)
    # Vote differential index per party (LS24 share minus AS23 share).
    dvi = db.Column(db.JSON)
    # Anti-BRS consolidation index (INC + BJP share in AS23).
    aci_23 = db.Column(db.Float)
    # Turnout volatility across cycles (standard deviation).
    turnout_volatility = db.Column(db.Float)
    # Incumbency weakness factors per party.
    incumbency_weakness = db.Column(db.JSON)
    updated_at = db.Column(db.DateTime, nullable=False, default=func.now(), onupdate=func.now())

    def __repr__(self) -> str:  # pragma: no cover
        return f"<WardFeatures {self.ward_id}>"

