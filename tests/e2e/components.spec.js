import { test, expect } from '@playwright/test';\nimport { DashboardPage } from './pages/DashboardPage.js';\nimport { \n  EMOTIONS, SAMPLE_WARDS, VIEWPORT_SIZES, COMPONENT_SELECTORS \n} from './fixtures/testData.js';\nimport { \n  waitForPageStability, capturePageScreenshot, waitForChartsToLoad,\n  validateAccessibility, testKeyboardNavigation, mockApiResponse\n} from './utils/testHelpers.js';\n\ntest.describe('LokDarpan Components - Individual Testing', () => {\n  let dashboardPage;\n\n  test.beforeEach(async ({ page }) => {\n    dashboardPage = new DashboardPage(page);\n    await dashboardPage.goto();\n  });\n\n  test.describe('Strategic Summary Component', () => {\n    test('should display strategic summary content', async ({ page }) => {\n      await expect(dashboardPage.strategicSummary).toBeVisible();\n      \n      // Strategic summary should have content or loading state\n      const hasContent = await dashboardPage.strategicSummary.locator('text=Loading, text=Summary, text=Strategic, text=temporarily unavailable').count();\n      expect(hasContent).toBeGreaterThan(0);\n      \n      // Should respond to ward selection\n      await dashboardPage.selectWard('Jubilee Hills');\n      await waitForPageStability(page);\n      \n      // Content should update or show loading\n      await expect(dashboardPage.strategicSummary).toBeVisible();\n    });\n    \n    test('should handle strategic summary loading states', async ({ page }) => {\n      // Mock slow API response to test loading state\n      await mockApiResponse(page, '/api/v1/pulse/*', { loading: true }, { delay: 2000 });\n      \n      await dashboardPage.selectWard('Gachibowli');\n      \n      // Should show loading indicator\n      const loadingVisible = await dashboardPage.strategicSummary.locator('text=Loading, .animate-spin').isVisible({ timeout: 3000 }).catch(() => false);\n      \n      // Component should remain stable during loading\n      await expect(dashboardPage.strategicSummary).toBeVisible();\n    });\n  });\n\n  test.describe('Location Map Component', () => {\n    test('should display map or fallback interface', async ({ page }) => {\n      await expect(dashboardPage.mapContainer).toBeVisible();\n      \n      // Should have either functional map or fallback UI\n      const hasMapOrFallback = await dashboardPage.mapContainer.locator('canvas, svg, .leaflet-container, text=Interactive, text=temporarily unavailable').count();\n      expect(hasMapOrFallback).toBeGreaterThan(0);\n    });\n    \n    test('should handle map interactions gracefully', async ({ page }) => {\n      const isMapFunctional = await dashboardPage.validateMapFunctionality();\n      \n      if (isMapFunctional) {\n        // Test map clicking\n        await dashboardPage.clickOnMap({ x: 150, y: 150 });\n        \n        // Should not break after interaction\n        await expect(dashboardPage.mapContainer).toBeVisible();\n        await expect(dashboardPage.dashboardContainer).toBeVisible();\n      } else {\n        // Verify fallback UI is user-friendly\n        const fallbackText = await dashboardPage.mapContainer.textContent();\n        expect(fallbackText).toContain('ward'); // Should mention ward selection alternative\n      }\n    });\n    \n    test('should maintain height consistency', async ({ page }) => {\n      const mapHeight = await dashboardPage.mapContainer.boundingBox();\n      const summaryHeight = await dashboardPage.strategicSummary.boundingBox();\n      \n      // Heights should be reasonable (not collapsed or excessively tall)\n      expect(mapHeight.height).toBeGreaterThan(200);\n      expect(mapHeight.height).toBeLessThan(800);\n      \n      // Should be visually balanced with strategic summary\n      if (summaryHeight) {\n        const heightDifference = Math.abs(mapHeight.height - summaryHeight.height);\n        expect(heightDifference).toBeLessThan(200); // Reasonable height difference\n      }\n    });\n  });\n\n  test.describe('Emotion Chart Component', () => {\n    test('should render sentiment visualization', async ({ page }) => {\n      await expect(dashboardPage.sentimentChart).toBeVisible();\n      \n      // Should contain chart element\n      const chartElement = dashboardPage.sentimentChart.locator('canvas, svg');\n      await expect(chartElement).toBeVisible({ timeout: 10000 });\n      \n      // Chart should have reasonable dimensions\n      const boundingBox = await chartElement.boundingBox();\n      expect(boundingBox.width).toBeGreaterThan(100);\n      expect(boundingBox.height).toBeGreaterThan(100);\n    });\n    \n    test('should respond to emotion filter changes', async ({ page }) => {\n      // Set specific emotion filter\n      await dashboardPage.selectEmotion('Joy');\n      await waitForPageStability(page);\n      \n      // Chart should still be visible and functional\n      await expect(dashboardPage.sentimentChart).toBeVisible();\n      const chartElement = dashboardPage.sentimentChart.locator('canvas, svg');\n      await expect(chartElement).toBeVisible();\n      \n      // Test another emotion\n      await dashboardPage.selectEmotion('Anger');\n      await waitForPageStability(page);\n      \n      await expect(chartElement).toBeVisible();\n    });\n    \n    test('should handle empty data gracefully', async ({ page }) => {\n      // Mock empty data response\n      await mockApiResponse(page, '/api/v1/posts*', { items: [] });\n      \n      await dashboardPage.selectWard('All');\n      await waitForPageStability(page);\n      \n      // Component should not crash with empty data\n      await expect(dashboardPage.sentimentChart).toBeVisible();\n      \n      // Should show appropriate empty state or placeholder\n      const hasEmptyState = await dashboardPage.sentimentChart.locator('text=No data, text=Empty, canvas, svg').count();\n      expect(hasEmptyState).toBeGreaterThan(0);\n    });\n  });\n\n  test.describe('Competitive Analysis Component', () => {\n    test('should display party competition data', async ({ page }) => {\n      await expect(dashboardPage.competitiveAnalysis).toBeVisible();\n      \n      // Should show party information or loading state\n      const hasPartyData = await dashboardPage.competitiveAnalysis.locator('text=BJP, text=AIMIM, text=BRS, text=INC, text=Loading, canvas, svg').count();\n      expect(hasPartyData).toBeGreaterThan(0);\n    });\n    \n    test('should update with ward selection', async ({ page }) => {\n      const originalContent = await dashboardPage.competitiveAnalysis.textContent();\n      \n      // Change ward and verify update\n      await dashboardPage.selectWard('Jubilee Hills');\n      await waitForPageStability(page);\n      \n      // Component should remain visible\n      await expect(dashboardPage.competitiveAnalysis).toBeVisible();\n      \n      // Content may change or show loading\n      const updatedContent = await dashboardPage.competitiveAnalysis.textContent();\n      // Content should either be different or contain loading indicator\n      const hasUpdate = originalContent !== updatedContent || updatedContent.includes('Loading');\n      expect(hasUpdate).toBeTruthy();\n    });\n  });\n\n  test.describe('Time Series Chart Component', () => {\n    test('should render historical trend data', async ({ page }) => {\n      await expect(dashboardPage.timeSeriesChart).toBeVisible();\n      \n      // Wait for chart to load\n      const chartElement = dashboardPage.timeSeriesChart.locator('canvas, svg');\n      await expect(chartElement).toBeVisible({ timeout: 15000 });\n      \n      // Verify chart has content\n      const boundingBox = await chartElement.boundingBox();\n      expect(boundingBox.width).toBeGreaterThan(200);\n      expect(boundingBox.height).toBeGreaterThan(100);\n    });\n    \n    test('should handle different time periods', async ({ page }) => {\n      // Time series should be visible with default settings\n      await expect(dashboardPage.timeSeriesChart).toBeVisible();\n      \n      // Change ward to test data refresh\n      await dashboardPage.selectWard('Banjara Hills');\n      await waitForPageStability(page);\n      \n      // Chart should still be functional\n      const chartElement = dashboardPage.timeSeriesChart.locator('canvas, svg');\n      await expect(chartElement).toBeVisible();\n    });\n  });\n\n  test.describe('Topic Analysis Component', () => {\n    test('should display topic clustering results', async ({ page }) => {\n      await expect(dashboardPage.topicAnalysis).toBeVisible();\n      \n      // Should show topic information\n      const hasTopicContent = await dashboardPage.topicAnalysis.locator('canvas, svg, text=Topic, text=Loading, text=temporarily unavailable').count();\n      expect(hasTopicContent).toBeGreaterThan(0);\n    });\n    \n    test('should respond to keyword filtering', async ({ page }) => {\n      await dashboardPage.searchKeyword('infrastructure');\n      await waitForPageStability(page);\n      \n      // Topic analysis should remain visible\n      await expect(dashboardPage.topicAnalysis).toBeVisible();\n      \n      // Clear keyword and test again\n      await dashboardPage.clearKeywordSearch();\n      await waitForPageStability(page);\n      \n      await expect(dashboardPage.topicAnalysis).toBeVisible();\n    });\n  });\n\n  test.describe('Alerts Panel Component', () => {\n    test('should display intelligence alerts', async ({ page }) => {\n      await expect(dashboardPage.alertsPanel).toBeVisible();\n      \n      // Should show alerts or empty state\n      const hasAlertContent = await dashboardPage.alertsPanel.locator('text=Alert, text=Intelligence, text=No alerts, text=Loading, text=temporarily unavailable').count();\n      expect(hasAlertContent).toBeGreaterThan(0);\n    });\n    \n    test('should update with ward changes', async ({ page }) => {\n      await dashboardPage.selectWard('Hitech City');\n      await waitForPageStability(page);\n      \n      // Alerts panel should remain functional\n      await expect(dashboardPage.alertsPanel).toBeVisible();\n    });\n  });\n\n  test.describe('Ward Meta Panel Component', () => {\n    test('should display ward demographic information', async ({ page }) => {\n      await expect(dashboardPage.wardMetaPanel).toBeVisible();\n      \n      // Should show demographic data or loading state\n      const hasMetaContent = await dashboardPage.wardMetaPanel.locator('text=Ward, text=Population, text=Demographics, text=Loading, text=temporarily unavailable').count();\n      expect(hasMetaContent).toBeGreaterThan(0);\n    });\n  });\n\n  test.describe('Filter Components', () => {\n    test('should validate emotion filter functionality', async ({ page }) => {\n      await expect(dashboardPage.emotionFilter).toBeVisible();\n      await expect(dashboardPage.emotionFilter).toBeEnabled();\n      \n      // Should have all expected emotions\n      await dashboardPage.emotionFilter.click();\n      const options = await dashboardPage.emotionFilter.locator('option').allTextContents();\n      \n      // Should include basic emotions\n      expect(options).toContain('All');\n      expect(options).toContain('Joy');\n      expect(options).toContain('Anger');\n      \n      await dashboardPage.emotionFilter.press('Escape');\n    });\n    \n    test('should validate ward dropdown functionality', async ({ page }) => {\n      await expect(dashboardPage.wardDropdown).toBeVisible();\n      await expect(dashboardPage.wardDropdown).toBeEnabled();\n      \n      // Should have ward options\n      const wards = await dashboardPage.getAvailableWards();\n      expect(wards.length).toBeGreaterThan(1);\n      expect(wards).toContain('All');\n    });\n    \n    test('should validate keyword search functionality', async ({ page }) => {\n      await expect(dashboardPage.keywordSearch).toBeVisible();\n      await expect(dashboardPage.keywordSearch).toBeEnabled();\n      \n      // Should accept input\n      await dashboardPage.keywordSearch.fill('test search');\n      expect(await dashboardPage.keywordSearch.inputValue()).toBe('test search');\n      \n      // Should clear properly\n      await dashboardPage.keywordSearch.clear();\n      expect(await dashboardPage.keywordSearch.inputValue()).toBe('');\n    });\n  });\n\n  test.describe('Component Accessibility', () => {\n    test('should meet basic accessibility requirements', async ({ page }) => {\n      const accessibilityResults = await validateAccessibility(page);\n      \n      // Should have minimal accessibility violations\n      expect(accessibilityResults.violations.length).toBeLessThan(5);\n      \n      if (accessibilityResults.violations.length > 0) {\n        console.warn('Accessibility violations:', accessibilityResults.violations);\n      }\n    });\n    \n    test('should support keyboard navigation', async ({ page }) => {\n      // Start with emotion filter\n      await dashboardPage.emotionFilter.focus();\n      \n      // Test tab navigation through key components\n      const focusOrder = await testKeyboardNavigation(page, dashboardPage.emotionFilter);\n      \n      // Should be able to navigate through multiple interactive elements\n      expect(focusOrder.length).toBeGreaterThan(3);\n      \n      // Key interactive elements should be in focus order\n      const focusedElements = focusOrder.map(f => f.element);\n      expect(focusedElements).toContain('SELECT'); // Dropdowns\n      expect(focusedElements).toContain('INPUT');  // Search input\n    });\n  });\n\n  test.describe('Component Error Handling', () => {\n    test('should handle API errors gracefully', async ({ page }) => {\n      // Mock API error for posts\n      await mockApiResponse(page, '/api/v1/posts*', { error: 'Server Error' }, { status: 500 });\n      \n      await dashboardPage.selectWard('Jubilee Hills');\n      await waitForPageStability(page);\n      \n      // Components should not crash\n      await expect(dashboardPage.dashboardContainer).toBeVisible();\n      await expect(dashboardPage.sentimentChart).toBeVisible();\n      \n      // Error boundaries may be active\n      const errorBoundaries = await dashboardPage.checkForErrorBoundaries();\n      // Some errors are acceptable for fallback handling\n    });\n    \n    test('should handle network timeouts', async ({ page }) => {\n      // Mock slow response\n      await mockApiResponse(page, '/api/v1/competitive-analysis*', { data: 'delayed' }, { delay: 10000 });\n      \n      await dashboardPage.selectWard('Madhapur');\n      \n      // Should show loading states\n      const hasLoading = await page.locator('text=Loading, .animate-spin').isVisible({ timeout: 3000 }).catch(() => false);\n      \n      // Dashboard should remain stable during slow responses\n      await expect(dashboardPage.dashboardContainer).toBeVisible();\n    });\n  });\n\n  test.describe('Component Responsive Behavior', () => {\n    test('should adapt to mobile viewport', async ({ page }) => {\n      await page.setViewportSize(VIEWPORT_SIZES.mobile);\n      await page.waitForTimeout(1000);\n      \n      // All major components should be visible on mobile\n      await expect(dashboardPage.strategicSummary).toBeVisible();\n      await expect(dashboardPage.mapContainer).toBeVisible();\n      await expect(dashboardPage.sentimentChart).toBeVisible();\n      \n      // Charts should adapt to smaller screen\n      const chartElement = dashboardPage.sentimentChart.locator('canvas, svg').first();\n      const boundingBox = await chartElement.boundingBox();\n      expect(boundingBox.width).toBeLessThan(400); // Should fit mobile screen\n    });\n    \n    test('should maintain functionality on tablet', async ({ page }) => {\n      await page.setViewportSize(VIEWPORT_SIZES.tablet);\n      await page.waitForTimeout(1000);\n      \n      // Test filter interactions on tablet\n      await dashboardPage.selectEmotion('Hopeful');\n      await dashboardPage.selectWard('Kondapur');\n      \n      await waitForPageStability(page);\n      \n      // Components should remain functional\n      await expect(dashboardPage.competitiveAnalysis).toBeVisible();\n      await expect(dashboardPage.timeSeriesChart).toBeVisible();\n    });\n  });\n\n  test.describe('Component Performance', () => {\n    test('should render charts within reasonable time', async ({ page }) => {\n      const startTime = Date.now();\n      \n      // Trigger chart re-render\n      await dashboardPage.selectWard('Miyapur');\n      \n      // Wait for charts to load\n      await waitForChartsToLoad(page, 10000);\n      \n      const loadTime = Date.now() - startTime;\n      \n      // Charts should load within 10 seconds\n      expect(loadTime).toBeLessThan(10000);\n    });\n    \n    test('should handle multiple rapid filter changes', async ({ page }) => {\n      // Rapidly change filters\n      for (let i = 0; i < 5; i++) {\n        await dashboardPage.selectEmotion(EMOTIONS[i % EMOTIONS.length]);\n        await page.waitForTimeout(200); // Short delay between changes\n      }\n      \n      // Dashboard should remain stable\n      await waitForPageStability(page);\n      await expect(dashboardPage.dashboardContainer).toBeVisible();\n      \n      // Charts should still render\n      const chartCount = await dashboardPage.charts.count();\n      expect(chartCount).toBeGreaterThan(0);\n    });\n  });\n});