import { test, expect } from '@playwright/test';\nimport { DashboardPage } from './pages/DashboardPage.js';\nimport { \n  ERROR_SCENARIOS, MOCK_RESPONSES \n} from './fixtures/testData.js';\nimport { \n  waitForPageStability, mockApiResponse, capturePageScreenshot\n} from './utils/testHelpers.js';\n\ntest.describe('LokDarpan Error Boundary & Error Handling Tests', () => {\n  let dashboardPage;\n  let consoleErrors = [];\n  let pageErrors = [];\n\n  test.beforeEach(async ({ page }) => {\n    dashboardPage = new DashboardPage(page);\n    consoleErrors = [];\n    pageErrors = [];\n    \n    // Capture JavaScript errors\n    page.on('console', msg => {\n      if (msg.type() === 'error') {\n        consoleErrors.push(msg.text());\n      }\n    });\n    \n    page.on('pageerror', error => {\n      pageErrors.push(error.message);\n    });\n    \n    await dashboardPage.goto();\n  });\n\n  test.afterEach(async ({ page }, testInfo) => {\n    if (testInfo.status === 'failed') {\n      await capturePageScreenshot(page, testInfo, '-error-handling-failure');\n    }\n    \n    // Report any critical errors\n    const criticalErrors = consoleErrors.filter(error => \n      !error.includes('Failed to load resource') && \n      !error.includes('favicon') &&\n      !error.includes('net::')\n    );\n    \n    if (criticalErrors.length > 0) {\n      console.warn('Critical JavaScript errors detected:', criticalErrors);\n    }\n  });\n\n  test.describe('Component Error Boundary Isolation', () => {\n    test('should isolate Strategic Summary component errors', async ({ page }) => {\n      await test.step('Simulate Strategic Summary API failure', async () => {\n        // Mock API error for strategic summary endpoint\n        await mockApiResponse(page, '/api/v1/pulse/*', \n          { error: 'Strategic analysis service unavailable' }, \n          { status: 500 }\n        );\n        \n        await dashboardPage.selectWard('Jubilee Hills');\n        await waitForPageStability(page);\n      });\n      \n      await test.step('Verify error boundary activation', async () => {\n        // Strategic summary may show error boundary\n        const strategicSummaryVisible = await dashboardPage.strategicSummary.isVisible();\n        expect(strategicSummaryVisible).toBeTruthy();\n        \n        // Check for fallback message\n        const fallbackText = await dashboardPage.strategicSummary.textContent();\n        const hasErrorMessage = fallbackText.includes('temporarily unavailable') ||\n                               fallbackText.includes('Strategic') ||\n                               fallbackText.includes('Loading');\n        expect(hasErrorMessage).toBeTruthy();\n      });\n      \n      await test.step('Verify other components remain functional', async () => {\n        // Other components should continue working\n        await expect(dashboardPage.sentimentChart).toBeVisible();\n        await expect(dashboardPage.competitiveAnalysis).toBeVisible();\n        await expect(dashboardPage.timeSeriesChart).toBeVisible();\n        \n        // User interactions should still work\n        await dashboardPage.selectEmotion('Joy');\n        await waitForPageStability(page);\n        \n        await expect(dashboardPage.emotionFilter).toHaveValue('Joy');\n        \n        // Dashboard remains navigable\n        await expect(dashboardPage.wardDropdown).toBeEnabled();\n        await expect(dashboardPage.keywordSearch).toBeEnabled();\n      });\n    });\n\n    test('should isolate Map component errors', async ({ page }) => {\n      await test.step('Simulate geospatial service failure', async () => {\n        // Mock geojson API failure\n        await mockApiResponse(page, '/api/v1/geojson*', \n          { error: 'Geospatial service unavailable' }, \n          { status: 503 }\n        );\n        \n        await page.reload();\n        await dashboardPage.waitForDashboardLoad();\n      });\n      \n      await test.step('Verify map fallback functionality', async () => {\n        // Map container should still be visible with fallback\n        await expect(dashboardPage.mapContainer).toBeVisible();\n        \n        // Should show helpful fallback message\n        const mapContent = await dashboardPage.mapContainer.textContent();\n        const hasMapFallback = mapContent.includes('Interactive') ||\n                              mapContent.includes('ward') ||\n                              mapContent.includes('temporarily unavailable');\n        expect(hasMapFallback).toBeTruthy();\n      });\n      \n      await test.step('Verify ward selection still works via dropdown', async () => {\n        // Ward dropdown should still function\n        await dashboardPage.selectWard('Banjara Hills');\n        await waitForPageStability(page);\n        \n        // Other components should update\n        await expect(dashboardPage.strategicSummary).toBeVisible();\n        await expect(dashboardPage.competitiveAnalysis).toBeVisible();\n        \n        // Dashboard functionality preserved\n        expect(await dashboardPage.wardDropdown.inputValue()).toBe('Banjara Hills');\n      });\n    });\n\n    test('should isolate chart component errors', async ({ page }) => {\n      await test.step('Simulate data visualization failure', async () => {\n        // Mock posts API failure\n        await mockApiResponse(page, '/api/v1/posts*', \n          { error: 'Post data service unavailable' }, \n          { status: 500 }\n        );\n        \n        await dashboardPage.selectWard('Gachibowli');\n        await waitForPageStability(page);\n      });\n      \n      await test.step('Verify chart error boundaries', async () => {\n        // Sentiment chart should handle empty/error data gracefully\n        await expect(dashboardPage.sentimentChart).toBeVisible();\n        \n        const chartContent = await dashboardPage.sentimentChart.textContent();\n        const hasChartContent = chartContent.includes('Sentiment') ||\n                               chartContent.includes('Loading') ||\n                               chartContent.includes('temporarily unavailable');\n        expect(hasChartContent).toBeTruthy();\n      });\n      \n      await test.step('Verify dashboard stability', async () => {\n        // Dashboard should not crash\n        await expect(dashboardPage.dashboardContainer).toBeVisible();\n        \n        // Filters should remain functional\n        await dashboardPage.selectEmotion('Anger');\n        await dashboardPage.searchKeyword('test');\n        \n        // No cascading failures\n        await expect(dashboardPage.emotionFilter).toBeEnabled();\n        await expect(dashboardPage.keywordSearch).toBeEnabled();\n      });\n    });\n\n    test('should isolate competitive analysis errors', async ({ page }) => {\n      await test.step('Simulate competitive analysis failure', async () => {\n        // Mock competitive analysis API failure\n        await mockApiResponse(page, '/api/v1/competitive-analysis*', \n          { error: 'Competitive analysis unavailable' }, \n          { status: 502 }\n        );\n        \n        await dashboardPage.selectWard('Madhapur');\n        await waitForPageStability(page);\n      });\n      \n      await test.step('Verify competitive analysis error handling', async () => {\n        // Competitive analysis component should show fallback\n        await expect(dashboardPage.competitiveAnalysis).toBeVisible();\n        \n        const competitiveContent = await dashboardPage.competitiveAnalysis.textContent();\n        const hasValidContent = competitiveContent.includes('Competitive') ||\n                               competitiveContent.includes('temporarily unavailable') ||\n                               competitiveContent.includes('Loading');\n        expect(hasValidContent).toBeTruthy();\n      });\n      \n      await test.step('Verify trend analysis isolation', async () => {\n        // Related competitive components should handle errors\n        await expect(dashboardPage.competitorTrend).toBeVisible();\n        await expect(dashboardPage.competitiveBenchmark).toBeVisible();\n        \n        // Other components unaffected\n        await expect(dashboardPage.sentimentChart).toBeVisible();\n        await expect(dashboardPage.timeSeriesChart).toBeVisible();\n      });\n    });\n  });\n\n  test.describe('API Error Scenario Handling', () => {\n    test('should handle server errors gracefully', async ({ page }) => {\n      const errorScenarios = [\n        { endpoint: '/api/v1/posts*', ...ERROR_SCENARIOS.serverError },\n        { endpoint: '/api/v1/trends*', ...ERROR_SCENARIOS.serverError },\n        { endpoint: '/api/v1/ward/meta/*', ...ERROR_SCENARIOS.serverError }\n      ];\n      \n      for (const scenario of errorScenarios) {\n        await test.step(`Handle ${scenario.description}`, async () => {\n          // Mock the error response\n          await mockApiResponse(page, scenario.endpoint, \n            scenario.response.error, \n            { status: scenario.response.status }\n          );\n          \n          // Trigger API call\n          await dashboardPage.selectWard('Hitech City');\n          await waitForPageStability(page);\n          \n          // Dashboard should remain functional\n          await expect(dashboardPage.dashboardContainer).toBeVisible();\n          \n          // Error should not cascade to other components\n          const errorBoundaryCount = await dashboardPage.checkForErrorBoundaries();\n          expect(errorBoundaryCount).toBeLessThan(10); // Reasonable limit\n        });\n      }\n    });\n\n    test('should handle network timeouts', async ({ page }) => {\n      await test.step('Simulate slow API responses', async () => {\n        // Mock extremely slow responses\n        await mockApiResponse(page, '/api/v1/pulse/*', \n          { data: 'delayed response' }, \n          { delay: 15000 }\n        );\n        \n        await dashboardPage.selectWard('Kondapur');\n      });\n      \n      await test.step('Verify timeout handling', async () => {\n        // Should show loading states initially\n        const hasLoading = await page.locator('text=Loading, .animate-spin').isVisible({ timeout: 3000 }).catch(() => false);\n        \n        // Dashboard should remain responsive during slow loads\n        await expect(dashboardPage.emotionFilter).toBeEnabled();\n        await expect(dashboardPage.wardDropdown).toBeEnabled();\n        \n        // User can continue interacting with other components\n        await dashboardPage.selectEmotion('Hopeful');\n        await expect(dashboardPage.emotionFilter).toHaveValue('Hopeful');\n      });\n    });\n\n    test('should handle authentication errors', async ({ page }) => {\n      await test.step('Simulate authentication failure', async () => {\n        // Mock 401 unauthorized response\n        await mockApiResponse(page, '/api/v1/posts*', \n          { error: 'Unauthorized' }, \n          { status: 401 }\n        );\n        \n        await dashboardPage.selectWard('Miyapur');\n        await waitForPageStability(page);\n      });\n      \n      await test.step('Verify authentication error handling', async () => {\n        // Dashboard should not redirect to login automatically\n        await expect(dashboardPage.dashboardContainer).toBeVisible();\n        \n        // Components should show appropriate fallback states\n        const hasErrorFallback = await page.locator('text=temporarily unavailable, text=Loading, text=error').count();\n        expect(hasErrorFallback).toBeGreaterThan(0);\n      });\n    });\n  });\n\n  test.describe('JavaScript Error Recovery', () => {\n    test('should recover from component render errors', async ({ page }) => {\n      await test.step('Trigger potential render errors', async () => {\n        // Rapid state changes that might cause render issues\n        for (let i = 0; i < 10; i++) {\n          await dashboardPage.selectWard(i % 2 === 0 ? 'Jubilee Hills' : 'All');\n          await page.waitForTimeout(100);\n        }\n        \n        await waitForPageStability(page);\n      });\n      \n      await test.step('Verify recovery from render stress', async () => {\n        // Dashboard should stabilize\n        await expect(dashboardPage.dashboardContainer).toBeVisible();\n        \n        // Components should be functional\n        await expect(dashboardPage.sentimentChart).toBeVisible();\n        await expect(dashboardPage.competitiveAnalysis).toBeVisible();\n        \n        // Interactions should work normally\n        await dashboardPage.selectEmotion('Joy');\n        expect(await dashboardPage.emotionFilter.inputValue()).toBe('Joy');\n      });\n    });\n\n    test('should handle memory pressure gracefully', async ({ page }) => {\n      await test.step('Create memory pressure scenario', async () => {\n        // Rapidly change filters to create many component updates\n        const emotions = ['Joy', 'Anger', 'Hopeful', 'Fear', 'Sadness'];\n        const wards = ['Jubilee Hills', 'Gachibowli', 'Banjara Hills', 'Hitech City'];\n        \n        for (let i = 0; i < 20; i++) {\n          await dashboardPage.selectEmotion(emotions[i % emotions.length]);\n          await dashboardPage.selectWard(wards[i % wards.length]);\n          await page.waitForTimeout(50);\n        }\n      });\n      \n      await test.step('Verify memory management', async () => {\n        await waitForPageStability(page);\n        \n        // System should remain stable\n        await expect(dashboardPage.dashboardContainer).toBeVisible();\n        \n        // Components should still render\n        const chartCount = await dashboardPage.charts.count();\n        expect(chartCount).toBeGreaterThan(0);\n        \n        // No memory-related crashes\n        expect(pageErrors.filter(error => error.includes('memory')).length).toBe(0);\n      });\n    });\n  });\n\n  test.describe('Error Boundary User Experience', () => {\n    test('should provide meaningful error messages', async ({ page }) => {\n      await test.step('Trigger various error scenarios', async () => {\n        // Mock different types of failures\n        const errorMocks = [\n          { endpoint: '/api/v1/pulse/*', error: 'AI service temporarily unavailable' },\n          { endpoint: '/api/v1/posts*', error: 'Data service maintenance' },\n          { endpoint: '/api/v1/competitive-analysis*', error: 'Analysis engine offline' }\n        ];\n        \n        for (const mock of errorMocks) {\n          await mockApiResponse(page, mock.endpoint, { error: mock.error }, { status: 503 });\n        }\n        \n        await dashboardPage.selectWard('Kondapur');\n        await waitForPageStability(page);\n      });\n      \n      await test.step('Verify user-friendly error messages', async () => {\n        // Error messages should be user-friendly, not technical\n        const errorMessages = await page.locator('text=temporarily unavailable, text=Please try again, text=service').all();\n        \n        for (const message of errorMessages) {\n          const text = await message.textContent();\n          \n          // Should not contain technical jargon\n          expect(text).not.toContain('500');\n          expect(text).not.toContain('undefined');\n          expect(text).not.toContain('null');\n          expect(text).not.toContain('error:');\n          \n          // Should be informative\n          expect(text.length).toBeGreaterThan(10);\n        }\n      });\n    });\n\n    test('should maintain navigation during errors', async ({ page }) => {\n      await test.step('Simulate partial system failure', async () => {\n        // Multiple components experiencing issues\n        await mockApiResponse(page, '/api/v1/pulse/*', { error: 'Service down' }, { status: 500 });\n        await mockApiResponse(page, '/api/v1/trends*', { error: 'Service down' }, { status: 500 });\n        \n        await dashboardPage.selectWard('Miyapur');\n        await waitForPageStability(page);\n      });\n      \n      await test.step('Verify continued navigation capability', async () => {\n        // User should still be able to navigate\n        await expect(dashboardPage.wardDropdown).toBeEnabled();\n        await expect(dashboardPage.emotionFilter).toBeEnabled();\n        await expect(dashboardPage.keywordSearch).toBeEnabled();\n        \n        // Can change wards despite errors\n        await dashboardPage.selectWard('Gachibowli');\n        expect(await dashboardPage.wardDropdown.inputValue()).toBe('Gachibowli');\n        \n        // Can apply filters\n        await dashboardPage.selectEmotion('Anger');\n        expect(await dashboardPage.emotionFilter.inputValue()).toBe('Anger');\n        \n        // Can search\n        await dashboardPage.searchKeyword('urgent');\n        expect(await dashboardPage.keywordSearch.inputValue()).toBe('urgent');\n      });\n    });\n\n    test('should provide error recovery options', async ({ page }) => {\n      await test.step('Create recoverable error scenario', async () => {\n        // Temporary service failure\n        await mockApiResponse(page, '/api/v1/posts*', \n          { error: 'Temporary service interruption' }, \n          { status: 503 }\n        );\n        \n        await dashboardPage.selectWard('Jubilee Hills');\n        await waitForPageStability(page);\n      });\n      \n      await test.step('Test error recovery workflow', async () => {\n        // Remove error mock to simulate service recovery\n        await page.unroute('**/api/v1/posts*');\n        \n        // User can retry by changing ward\n        await dashboardPage.selectWard('All');\n        await dashboardPage.selectWard('Jubilee Hills');\n        await waitForPageStability(page);\n        \n        // System should recover\n        await expect(dashboardPage.sentimentChart).toBeVisible();\n        \n        // Verify functionality restored\n        const chartElements = await dashboardPage.charts.count();\n        expect(chartElements).toBeGreaterThan(0);\n      });\n    });\n  });\n\n  test.describe('Cascade Failure Prevention', () => {\n    test('should prevent single component failure from breaking entire dashboard', async ({ page }) => {\n      await test.step('Simulate catastrophic component failure', async () => {\n        // Mock all possible API failures\n        const criticalEndpoints = [\n          '/api/v1/posts*',\n          '/api/v1/competitive-analysis*',\n          '/api/v1/trends*',\n          '/api/v1/pulse/*',\n          '/api/v1/ward/meta/*'\n        ];\n        \n        for (const endpoint of criticalEndpoints) {\n          await mockApiResponse(page, endpoint, \n            { error: 'System maintenance' }, \n            { status: 503 }\n          );\n        }\n        \n        await dashboardPage.selectWard('Banjara Hills');\n        await waitForPageStability(page);\n      });\n      \n      await test.step('Verify dashboard core functionality preserved', async () => {\n        // Main dashboard structure should remain\n        await expect(dashboardPage.dashboardContainer).toBeVisible();\n        \n        // Filter controls should work\n        await expect(dashboardPage.emotionFilter).toBeEnabled();\n        await expect(dashboardPage.wardDropdown).toBeEnabled();\n        await expect(dashboardPage.keywordSearch).toBeEnabled();\n        \n        // User can still interact with the system\n        await dashboardPage.selectEmotion('Joy');\n        await dashboardPage.searchKeyword('test');\n        \n        // No white screen of death\n        const bodyContent = await page.textContent('body');\n        expect(bodyContent.length).toBeGreaterThan(100);\n      });\n      \n      await test.step('Verify graceful degradation', async () => {\n        // Error boundaries should be active but not overwhelming\n        const errorBoundaryCount = await dashboardPage.checkForErrorBoundaries();\n        expect(errorBoundaryCount).toBeGreaterThan(0); // Some errors expected\n        expect(errorBoundaryCount).toBeLessThan(15); // But not excessive\n        \n        // Should show helpful degradation messages\n        const pageContent = await page.textContent('body');\n        expect(pageContent).toContain('temporarily unavailable');\n      });\n    });\n\n    test('should maintain system stability under error conditions', async ({ page }) => {\n      // Test multiple error scenarios simultaneously\n      const stressScenarios = [\n        () => mockApiResponse(page, '/api/v1/geojson*', { error: 'Map service down' }, { status: 503 }),\n        () => dashboardPage.selectWard('Invalid Ward'),\n        () => dashboardPage.searchKeyword(''),\n        () => page.setViewportSize({ width: 100, height: 100 }), // Extreme resize\n      ];\n      \n      // Execute stress scenarios\n      for (const scenario of stressScenarios) {\n        await scenario().catch(() => {}); // Allow failures\n        await page.waitForTimeout(500);\n      }\n      \n      await waitForPageStability(page);\n      \n      // System should remain stable\n      await expect(dashboardPage.dashboardContainer).toBeVisible();\n      \n      // Critical functionality preserved\n      await expect(dashboardPage.wardDropdown).toBeEnabled();\n      \n      // No complete system failure\n      expect(pageErrors.length).toBeLessThan(5);\n    });\n  });\n});