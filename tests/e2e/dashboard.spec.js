import { test, expect } from '@playwright/test';\nimport { DashboardPage } from './pages/DashboardPage.js';\nimport { \n  EMOTIONS, SAMPLE_WARDS, TEST_KEYWORDS, VIEWPORT_SIZES \n} from './fixtures/testData.js';\nimport { \n  waitForPageStability, validateNoJSErrors, capturePageScreenshot,\n  waitForChartsToLoad, simulateHumanInteraction\n} from './utils/testHelpers.js';\n\ntest.describe('LokDarpan Dashboard - Comprehensive Tests', () => {\n  let dashboardPage;\n  let jsErrors = [];\n\n  test.beforeEach(async ({ page }) => {\n    // Initialize Page Object and error tracking\n    dashboardPage = new DashboardPage(page);\n    jsErrors = await validateNoJSErrors(page, ['favicon', 'Failed to load resource']);\n    \n    // Navigate to dashboard\n    await dashboardPage.goto();\n  });\n\n  test.afterEach(async ({ page }, testInfo) => {\n    // Capture screenshot on failure\n    if (testInfo.status === 'failed') {\n      await capturePageScreenshot(page, testInfo, '-failure');\n    }\n    \n    // Report JavaScript errors\n    if (jsErrors.length > 0) {\n      console.warn('JavaScript errors detected:', jsErrors);\n    }\n  });\n\n  test('should load dashboard and display all core components', async ({ page }) => {\n    // Validate authentication is working\n    await dashboardPage.validateAuthentication();\n    \n    // Wait for all components to load\n    await waitForPageStability(page);\n    \n    // Validate core components are visible\n    await dashboardPage.validateCoreComponents();\n    \n    // Validate advanced analytics components\n    await dashboardPage.validateAdvancedAnalytics();\n    \n    // Verify charts are rendered\n    const chartCount = await dashboardPage.validateChartsRender();\n    expect(chartCount).toBeGreaterThan(0);\n    \n    // Check that no error boundaries are active\n    const errorCount = await dashboardPage.checkForErrorBoundaries();\n    expect(errorCount).toBeLessThan(3); // Allow some fallback components\n  });\n\n  test('should handle ward selection via dropdown', async ({ page }) => {\n    // Get available wards\n    const availableWards = await dashboardPage.getAvailableWards();\n    expect(availableWards.length).toBeGreaterThan(1);\n    \n    // Test ward selection with different wards\n    const testWards = availableWards.slice(0, 3); // Test first 3 wards\n    \n    for (const ward of testWards) {\n      await test.step(`Testing ward selection: ${ward}`, async () => {\n        await dashboardPage.selectWard(ward);\n        \n        // Wait for data to update\n        await waitForPageStability(page, { timeout: 15000 });\n        \n        // Validate data consistency\n        await dashboardPage.validateDataConsistency();\n        \n        // Verify ward selection persists\n        const selectedValue = await dashboardPage.wardDropdown.inputValue();\n        expect(selectedValue).toBe(ward);\n      });\n    }\n  });\n\n  test('should filter data by emotion categories', async ({ page }) => {\n    // Test different emotion filters\n    const testEmotions = ['All', 'Joy', 'Anger', 'Hopeful', 'Frustration'];\n    \n    for (const emotion of testEmotions) {\n      await test.step(`Testing emotion filter: ${emotion}`, async () => {\n        await dashboardPage.selectEmotion(emotion);\n        \n        // Wait for filtering to complete\n        await waitForPageStability(page);\n        \n        // Verify filter selection\n        const selectedEmotion = await dashboardPage.emotionFilter.inputValue();\n        expect(selectedEmotion).toBe(emotion);\n        \n        // Charts should still be visible after filtering\n        await expect(dashboardPage.charts.first()).toBeVisible();\n      });\n    }\n  });\n\n  test('should handle keyword search functionality', async ({ page }) => {\n    const testKeywords = TEST_KEYWORDS.slice(0, 3);\n    \n    for (const keyword of testKeywords) {\n      await test.step(`Testing keyword search: ${keyword}`, async () => {\n        await dashboardPage.searchKeyword(keyword);\n        \n        // Wait for search results\n        await waitForPageStability(page);\n        \n        // Verify search input contains keyword\n        const inputValue = await dashboardPage.keywordSearch.inputValue();\n        expect(inputValue).toBe(keyword);\n        \n        // Clear search for next iteration\n        await dashboardPage.clearKeywordSearch();\n        await waitForPageStability(page);\n      });\n    }\n  });\n\n  test('should handle responsive design across breakpoints', async ({ page }) => {\n    const breakpoints = {\n      desktop: VIEWPORT_SIZES.desktop,\n      laptop: VIEWPORT_SIZES.laptop,\n      tablet: VIEWPORT_SIZES.tablet,\n      mobile: VIEWPORT_SIZES.mobile\n    };\n    \n    for (const [name, size] of Object.entries(breakpoints)) {\n      await test.step(`Testing responsive design: ${name}`, async () => {\n        await page.setViewportSize(size);\n        await page.waitForTimeout(1000);\n        \n        // Validate layout is functional\n        const isResponsive = await dashboardPage.validateResponsiveLayout(size);\n        expect(isResponsive).toBeTruthy();\n        \n        // Core components should remain visible\n        await expect(dashboardPage.dashboardContainer).toBeVisible();\n        \n        // Filter controls should be accessible\n        if (size.width > 768) {\n          // On larger screens, all filters should be visible\n          await expect(dashboardPage.emotionFilter).toBeVisible();\n          await expect(dashboardPage.wardDropdown).toBeVisible();\n          await expect(dashboardPage.keywordSearch).toBeVisible();\n        } else {\n          // On mobile, at least one filter should be accessible\n          const filterVisible = await dashboardPage.emotionFilter.isVisible() ||\n                               await dashboardPage.wardDropdown.isVisible() ||\n                               await dashboardPage.keywordSearch.isVisible();\n          expect(filterVisible).toBeTruthy();\n        }\n      });\n    }\n  });\n\n  test('should validate data visualizations render correctly', async ({ page }) => {\n    // Wait for charts to fully load\n    const chartCount = await waitForChartsToLoad(page);\n    expect(chartCount).toBeGreaterThan(0);\n    \n    // Validate specific chart components\n    await test.step('Sentiment Chart Validation', async () => {\n      await expect(dashboardPage.sentimentChart).toBeVisible();\n      const sentimentCanvas = dashboardPage.sentimentChart.locator('canvas, svg').first();\n      await expect(sentimentCanvas).toBeVisible();\n    });\n    \n    await test.step('Competitive Analysis Validation', async () => {\n      await expect(dashboardPage.competitiveAnalysis).toBeVisible();\n      // Should contain party data or loading state\n      const hasContent = await dashboardPage.competitiveAnalysis.locator('canvas, svg, text=Loading').count();\n      expect(hasContent).toBeGreaterThan(0);\n    });\n    \n    await test.step('Time Series Chart Validation', async () => {\n      await expect(dashboardPage.timeSeriesChart).toBeVisible();\n      const timeSeriesCanvas = dashboardPage.timeSeriesChart.locator('canvas, svg').first();\n      await expect(timeSeriesCanvas).toBeVisible();\n    });\n    \n    // Take screenshots of key visualizations\n    await dashboardPage.takeComponentScreenshots(test.info());\n  });\n\n  test('should handle ward selection via map interaction', async ({ page }) => {\n    // Check if map is functional\n    const isMapFunctional = await dashboardPage.validateMapFunctionality();\n    \n    if (isMapFunctional) {\n      await test.step('Map Click Interaction', async () => {\n        // Click on different areas of the map\n        const mapCoordinates = [\n          { x: 100, y: 100 },\n          { x: 200, y: 150 },\n          { x: 150, y: 200 }\n        ];\n        \n        for (const coords of mapCoordinates) {\n          await dashboardPage.clickOnMap(coords);\n          await waitForPageStability(page);\n          \n          // Verify that clicking doesn't break the interface\n          await expect(dashboardPage.dashboardContainer).toBeVisible();\n        }\n      });\n    } else {\n      // Map fallback should be displayed\n      const mapFallback = dashboardPage.mapContainer.locator('text=Interactive, text=temporarily unavailable');\n      await expect(mapFallback).toBeVisible();\n    }\n  });\n\n  test('should maintain state consistency across interactions', async ({ page }) => {\n    // Set initial state\n    await dashboardPage.selectWard('Jubilee Hills');\n    await dashboardPage.selectEmotion('Joy');\n    await dashboardPage.searchKeyword('roads');\n    \n    await waitForPageStability(page);\n    \n    // Capture initial state\n    const initialWard = await dashboardPage.wardDropdown.inputValue();\n    const initialEmotion = await dashboardPage.emotionFilter.inputValue();\n    const initialKeyword = await dashboardPage.keywordSearch.inputValue();\n    \n    // Trigger data refresh by changing and reverting ward\n    await dashboardPage.selectWard('All');\n    await waitForPageStability(page);\n    await dashboardPage.selectWard(initialWard);\n    await waitForPageStability(page);\n    \n    // Verify state consistency\n    expect(await dashboardPage.wardDropdown.inputValue()).toBe(initialWard);\n    expect(await dashboardPage.emotionFilter.inputValue()).toBe(initialEmotion);\n    expect(await dashboardPage.keywordSearch.inputValue()).toBe(initialKeyword);\n  });\n\n  test('should handle combined filter interactions', async ({ page }) => {\n    // Test realistic user workflow with multiple filters\n    const interactions = [\n      { type: 'select', selector: dashboardPage.wardDropdown, value: 'Jubilee Hills' },\n      { type: 'select', selector: dashboardPage.emotionFilter, value: 'Joy' },\n      { type: 'type', selector: dashboardPage.keywordSearch, text: 'development', waitForResponse: true },\n      { type: 'select', selector: dashboardPage.emotionFilter, value: 'All' },\n      { type: 'click', selector: dashboardPage.keywordSearch },\n    ];\n    \n    // Execute realistic user interaction sequence\n    await simulateHumanInteraction(page, interactions);\n    \n    // Verify dashboard remains functional\n    await expect(dashboardPage.dashboardContainer).toBeVisible();\n    await expect(dashboardPage.charts.first()).toBeVisible();\n  });\n\n  test('should validate component error boundaries', async ({ page }) => {\n    // Verify no components have crashed\n    const errorBoundaryCount = await dashboardPage.checkForErrorBoundaries();\n    \n    // Some error boundaries may be active for unavailable services\n    // but should not exceed reasonable limits\n    expect(errorBoundaryCount).toBeLessThan(5);\n    \n    // Critical components should not be in error state\n    await expect(dashboardPage.sentimentChart).toBeVisible();\n    await expect(dashboardPage.competitiveAnalysis).toBeVisible();\n    \n    // Dashboard should remain navigable\n    await expect(dashboardPage.emotionFilter).toBeEnabled();\n    await expect(dashboardPage.wardDropdown).toBeEnabled();\n    await expect(dashboardPage.keywordSearch).toBeEnabled();\n  });\n\n  test('should handle page refresh and state recovery', async ({ page }) => {\n    // Set some filters\n    await dashboardPage.selectWard('Banjara Hills');\n    await dashboardPage.selectEmotion('Hopeful');\n    await waitForPageStability(page);\n    \n    // Refresh the page\n    await page.reload();\n    \n    // Wait for dashboard to reload\n    await dashboardPage.waitForDashboardLoad();\n    \n    // Verify dashboard is functional after refresh\n    await dashboardPage.validateCoreComponents();\n    \n    // Verify no critical JavaScript errors\n    const postRefreshErrors = await validateNoJSErrors(page, ['favicon', 'Failed to load resource']);\n    expect(postRefreshErrors.length).toBeLessThan(3);\n  });\n\n  test('should validate loading states and transitions', async ({ page }) => {\n    // Test loading state handling during ward changes\n    const testWards = ['All', 'Jubilee Hills', 'Gachibowli'];\n    \n    for (const ward of testWards) {\n      await dashboardPage.selectWard(ward);\n      \n      // Check for loading indicators\n      const loadingVisible = await dashboardPage.loadingIndicators.isVisible().catch(() => false);\n      \n      // Wait for loading to complete\n      await waitForPageStability(page);\n      \n      // Verify data has loaded\n      await expect(dashboardPage.dashboardContainer).toBeVisible();\n      \n      // Loading indicators should be gone\n      const loadingGone = await dashboardPage.loadingIndicators.isHidden().catch(() => true);\n      expect(loadingGone).toBeTruthy();\n    }\n  });\n});