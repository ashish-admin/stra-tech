import { test, expect } from '@playwright/test';\nimport { DashboardPage } from './pages/DashboardPage.js';\nimport { \n  PERFORMANCE_THRESHOLDS, VIEWPORT_SIZES \n} from './fixtures/testData.js';\nimport { \n  measureWebVitals, validatePerformance, setNetworkConditions,\n  waitForPageStability, capturePageScreenshot\n} from './utils/testHelpers.js';\n\ntest.describe('LokDarpan Performance & Core Web Vitals', () => {\n  let dashboardPage;\n\n  test.beforeEach(async ({ page }) => {\n    dashboardPage = new DashboardPage(page);\n  });\n\n  test.afterEach(async ({ page }, testInfo) => {\n    if (testInfo.status === 'failed') {\n      await capturePageScreenshot(page, testInfo, '-performance-failure');\n    }\n  });\n\n  test.describe('Core Web Vitals Measurements', () => {\n    test('should meet Core Web Vitals thresholds on desktop', async ({ page }) => {\n      await test.step('Load dashboard and measure vitals', async () => {\n        // Set desktop viewport\n        await page.setViewportSize(VIEWPORT_SIZES.desktop);\n        \n        // Navigate and measure load performance\n        const startTime = performance.now();\n        await dashboardPage.goto();\n        \n        // Measure Core Web Vitals\n        const webVitals = await measureWebVitals(page);\n        const loadTime = performance.now() - startTime;\n        \n        // Validate performance metrics\n        const performanceResult = validatePerformance({ \n          ...webVitals, \n          loadTime \n        });\n        \n        console.log('Desktop Performance Metrics:', performanceResult.metrics);\n        \n        // Core Web Vitals should meet good thresholds\n        if (webVitals.lcp) {\n          expect(webVitals.lcp).toBeLessThan(PERFORMANCE_THRESHOLDS.lcp);\n        }\n        \n        if (webVitals.fcp) {\n          expect(webVitals.fcp).toBeLessThan(PERFORMANCE_THRESHOLDS.fcp);\n        }\n        \n        if (webVitals.cls) {\n          expect(webVitals.cls).toBeLessThan(PERFORMANCE_THRESHOLDS.cls);\n        }\n        \n        // Total load time should be reasonable\n        expect(loadTime).toBeLessThan(PERFORMANCE_THRESHOLDS.loadTime);\n      });\n    });\n\n    test('should maintain performance on mobile devices', async ({ page }) => {\n      await test.step('Measure mobile performance', async () => {\n        // Set mobile viewport and simulate mobile conditions\n        await page.setViewportSize(VIEWPORT_SIZES.mobile);\n        await setNetworkConditions(page, 'fast3g');\n        \n        // Navigate and measure\n        const startTime = performance.now();\n        await dashboardPage.goto();\n        \n        const webVitals = await measureWebVitals(page);\n        const loadTime = performance.now() - startTime;\n        \n        console.log('Mobile Performance Metrics:', { ...webVitals, loadTime });\n        \n        // Mobile thresholds should be more lenient but still reasonable\n        if (webVitals.lcp) {\n          expect(webVitals.lcp).toBeLessThan(PERFORMANCE_THRESHOLDS.lcp * 1.5); // 50% more lenient\n        }\n        \n        // Mobile load time should be under 8 seconds\n        expect(loadTime).toBeLessThan(8000);\n      });\n    });\n\n    test('should handle slow network conditions gracefully', async ({ page }) => {\n      await test.step('Test performance on slow network', async () => {\n        // Simulate slow 3G connection\n        await setNetworkConditions(page, 'slow3g');\n        \n        const startTime = performance.now();\n        await dashboardPage.goto();\n        \n        // Should load within reasonable time even on slow connection\n        const loadTime = performance.now() - startTime;\n        expect(loadTime).toBeLessThan(15000); // 15 seconds max on slow 3G\n        \n        // Core functionality should be available\n        await expect(dashboardPage.dashboardContainer).toBeVisible();\n        await expect(dashboardPage.emotionFilter).toBeEnabled();\n      });\n    });\n  });\n\n  test.describe('Chart Rendering Performance', () => {\n    test('should render charts efficiently', async ({ page }) => {\n      await dashboardPage.goto();\n      \n      await test.step('Measure chart rendering time', async () => {\n        const startTime = performance.now();\n        \n        // Wait for all charts to load\n        await page.waitForSelector('canvas, svg', { timeout: 10000 });\n        await page.waitForTimeout(2000); // Additional render time\n        \n        const chartRenderTime = performance.now() - startTime;\n        \n        // Charts should render within 5 seconds\n        expect(chartRenderTime).toBeLessThan(5000);\n        \n        // Verify multiple charts are present\n        const chartCount = await dashboardPage.charts.count();\n        expect(chartCount).toBeGreaterThan(3);\n      });\n    });\n\n    test('should handle rapid filter changes efficiently', async ({ page }) => {\n      await dashboardPage.goto();\n      \n      await test.step('Measure filter response performance', async () => {\n        const filterChanges = [\n          () => dashboardPage.selectEmotion('Joy'),\n          () => dashboardPage.selectWard('Jubilee Hills'),\n          () => dashboardPage.selectEmotion('Anger'),\n          () => dashboardPage.searchKeyword('roads'),\n          () => dashboardPage.selectWard('Gachibowli')\n        ];\n        \n        const startTime = performance.now();\n        \n        // Execute rapid filter changes\n        for (const change of filterChanges) {\n          await change();\n          await page.waitForTimeout(500); // Minimal delay between changes\n        }\n        \n        await waitForPageStability(page);\n        const totalTime = performance.now() - startTime;\n        \n        // Rapid changes should complete within 10 seconds\n        expect(totalTime).toBeLessThan(10000);\n        \n        // Charts should still be functional\n        const chartCount = await dashboardPage.charts.count();\n        expect(chartCount).toBeGreaterThan(0);\n      });\n    });\n\n    test('should optimize memory usage during chart updates', async ({ page }) => {\n      await dashboardPage.goto();\n      \n      await test.step('Monitor memory during intensive chart operations', async () => {\n        // Get initial memory usage\n        const initialMemory = await page.evaluate(() => {\n          return (performance as any).memory ? (performance as any).memory.usedJSHeapSize : 0;\n        });\n        \n        // Perform memory-intensive operations\n        for (let i = 0; i < 20; i++) {\n          await dashboardPage.selectWard(i % 2 === 0 ? 'Jubilee Hills' : 'All');\n          await page.waitForTimeout(200);\n        }\n        \n        await waitForPageStability(page);\n        \n        // Check memory usage after operations\n        const finalMemory = await page.evaluate(() => {\n          return (performance as any).memory ? (performance as any).memory.usedJSHeapSize : 0;\n        });\n        \n        // Memory growth should be reasonable (less than 50MB increase)\n        if (initialMemory > 0 && finalMemory > 0) {\n          const memoryGrowth = finalMemory - initialMemory;\n          expect(memoryGrowth).toBeLessThan(50 * 1024 * 1024); // 50MB\n        }\n        \n        // Dashboard should remain functional\n        await expect(dashboardPage.dashboardContainer).toBeVisible();\n      });\n    });\n  });\n\n  test.describe('Data Loading Performance', () => {\n    test('should load initial dashboard data efficiently', async ({ page }) => {\n      await test.step('Measure initial data load performance', async () => {\n        // Track network requests\n        const networkRequests = [];\n        page.on('request', request => {\n          if (request.url().includes('/api/')) {\n            networkRequests.push({\n              url: request.url(),\n              method: request.method(),\n              timestamp: Date.now()\n            });\n          }\n        });\n        \n        const responses = [];\n        page.on('response', response => {\n          if (response.url().includes('/api/')) {\n            responses.push({\n              url: response.url(),\n              status: response.status(),\n              timestamp: Date.now()\n            });\n          }\n        });\n        \n        const startTime = Date.now();\n        await dashboardPage.goto();\n        await waitForPageStability(page);\n        const totalLoadTime = Date.now() - startTime;\n        \n        // API requests should complete quickly\n        expect(totalLoadTime).toBeLessThan(8000);\n        \n        // Should have made API requests\n        expect(networkRequests.length).toBeGreaterThan(0);\n        \n        // Most API responses should be successful\n        const successfulResponses = responses.filter(r => r.status >= 200 && r.status < 400);\n        const successRate = successfulResponses.length / responses.length;\n        expect(successRate).toBeGreaterThan(0.7); // At least 70% success rate\n      });\n    });\n\n    test('should handle large datasets efficiently', async ({ page }) => {\n      await dashboardPage.goto();\n      \n      await test.step('Test performance with comprehensive data', async () => {\n        // Select 'All' to get maximum dataset\n        const startTime = performance.now();\n        \n        await dashboardPage.selectWard('All');\n        await dashboardPage.selectEmotion('All');\n        await waitForPageStability(page);\n        \n        const processingTime = performance.now() - startTime;\n        \n        // Should handle large datasets within reasonable time\n        expect(processingTime).toBeLessThan(5000);\n        \n        // All components should render with large dataset\n        await expect(dashboardPage.sentimentChart).toBeVisible();\n        await expect(dashboardPage.competitiveAnalysis).toBeVisible();\n        await expect(dashboardPage.timeSeriesChart).toBeVisible();\n      });\n    });\n  });\n\n  test.describe('Responsive Performance', () => {\n    test('should maintain performance across viewport changes', async ({ page }) => {\n      await dashboardPage.goto();\n      \n      const viewports = [\n        { name: 'Desktop', size: VIEWPORT_SIZES.desktop },\n        { name: 'Tablet', size: VIEWPORT_SIZES.tablet },\n        { name: 'Mobile', size: VIEWPORT_SIZES.mobile }\n      ];\n      \n      for (const viewport of viewports) {\n        await test.step(`Test ${viewport.name} performance`, async () => {\n          const startTime = performance.now();\n          \n          await page.setViewportSize(viewport.size);\n          await page.waitForTimeout(1000); // Allow layout adjustment\n          \n          // Trigger re-render\n          await dashboardPage.selectWard('Jubilee Hills');\n          await waitForPageStability(page);\n          \n          const adaptationTime = performance.now() - startTime;\n          \n          // Viewport changes should be handled quickly\n          expect(adaptationTime).toBeLessThan(3000);\n          \n          // Core components should remain visible\n          await expect(dashboardPage.dashboardContainer).toBeVisible();\n          await expect(dashboardPage.sentimentChart).toBeVisible();\n        });\n      }\n    });\n  });\n\n  test.describe('JavaScript Performance', () => {\n    test('should maintain efficient JavaScript execution', async ({ page }) => {\n      await test.step('Monitor JavaScript performance metrics', async () => {\n        // Enable performance timeline\n        await page.addInitScript(() => {\n          window.performanceMetrics = {\n            scriptExecutionTime: 0,\n            domManipulationTime: 0\n          };\n        });\n        \n        await dashboardPage.goto();\n        \n        // Perform JavaScript-intensive operations\n        await dashboardPage.selectEmotion('Joy');\n        await dashboardPage.selectWard('Gachibowli');\n        await dashboardPage.searchKeyword('development');\n        await waitForPageStability(page);\n        \n        // Check for long-running JavaScript tasks\n        const longTasks = await page.evaluate(() => {\n          return new Promise((resolve) => {\n            const observer = new PerformanceObserver((list) => {\n              const longTaskEntries = list.getEntries().filter(entry => entry.duration > 50);\n              resolve(longTaskEntries.length);\n            });\n            observer.observe({ entryTypes: ['longtask'] });\n            \n            // Resolve after a delay if no long tasks detected\n            setTimeout(() => resolve(0), 2000);\n          });\n        });\n        \n        // Should have minimal long-running tasks\n        expect(longTasks).toBeLessThan(5);\n      });\n    });\n\n    test('should handle concurrent operations efficiently', async ({ page }) => {\n      await dashboardPage.goto();\n      \n      await test.step('Test concurrent filter operations', async () => {\n        const startTime = performance.now();\n        \n        // Simulate concurrent user actions\n        const concurrentActions = [\n          dashboardPage.selectEmotion('Anger'),\n          dashboardPage.selectWard('Hitech City'),\n          dashboardPage.searchKeyword('infrastructure')\n        ];\n        \n        // Execute actions concurrently\n        await Promise.all(concurrentActions);\n        await waitForPageStability(page);\n        \n        const executionTime = performance.now() - startTime;\n        \n        // Concurrent operations should complete efficiently\n        expect(executionTime).toBeLessThan(4000);\n        \n        // Verify all operations completed successfully\n        expect(await dashboardPage.emotionFilter.inputValue()).toBe('Anger');\n        expect(await dashboardPage.wardDropdown.inputValue()).toBe('Hitech City');\n        expect(await dashboardPage.keywordSearch.inputValue()).toBe('infrastructure');\n      });\n    });\n  });\n\n  test.describe('Resource Loading Performance', () => {\n    test('should optimize asset loading', async ({ page }) => {\n      const resourceLoadTimes = [];\n      \n      // Monitor resource loading\n      page.on('response', response => {\n        const timing = response.timing();\n        if (timing) {\n          resourceLoadTimes.push({\n            url: response.url(),\n            loadTime: timing.receiveHeadersEnd - timing.connectStart,\n            size: response.headers()['content-length'] || 0\n          });\n        }\n      });\n      \n      await test.step('Measure resource load performance', async () => {\n        await dashboardPage.goto();\n        await waitForPageStability(page);\n        \n        // Analyze resource load times\n        const slowResources = resourceLoadTimes.filter(resource => resource.loadTime > 2000);\n        \n        // Should not have too many slow-loading resources\n        expect(slowResources.length).toBeLessThan(3);\n        \n        // Log slow resources for analysis\n        if (slowResources.length > 0) {\n          console.log('Slow loading resources:', slowResources);\n        }\n      });\n    });\n\n    test('should handle offline/online transitions', async ({ page }) => {\n      await dashboardPage.goto();\n      \n      await test.step('Test offline resilience', async () => {\n        // Go offline\n        await page.context().setOffline(true);\n        \n        // Try to interact with dashboard\n        await dashboardPage.selectWard('Kondapur');\n        await page.waitForTimeout(2000);\n        \n        // Dashboard should remain stable\n        await expect(dashboardPage.dashboardContainer).toBeVisible();\n        \n        // Go back online\n        await page.context().setOffline(false);\n        \n        // Should recover gracefully\n        await dashboardPage.selectWard('Miyapur');\n        await waitForPageStability(page, { timeout: 10000 });\n        \n        // Verify recovery\n        await expect(dashboardPage.competitiveAnalysis).toBeVisible();\n      });\n    });\n  });\n\n  test.describe('Performance Regression Detection', () => {\n    test('should detect performance regressions', async ({ page }) => {\n      const performanceMetrics = [];\n      \n      // Run multiple performance measurements\n      for (let i = 0; i < 3; i++) {\n        await test.step(`Performance run ${i + 1}`, async () => {\n          const startTime = performance.now();\n          \n          // Clear browser cache for consistent measurement\n          await page.reload({ waitUntil: 'networkidle' });\n          await dashboardPage.goto();\n          \n          const loadTime = performance.now() - startTime;\n          const webVitals = await measureWebVitals(page);\n          \n          performanceMetrics.push({\n            run: i + 1,\n            loadTime,\n            ...webVitals\n          });\n        });\n      }\n      \n      // Analyze performance consistency\n      const loadTimes = performanceMetrics.map(m => m.loadTime);\n      const avgLoadTime = loadTimes.reduce((a, b) => a + b, 0) / loadTimes.length;\n      const maxDeviation = Math.max(...loadTimes.map(time => Math.abs(time - avgLoadTime)));\n      \n      // Performance should be consistent (deviation < 50% of average)\n      expect(maxDeviation).toBeLessThan(avgLoadTime * 0.5);\n      \n      // Average load time should be acceptable\n      expect(avgLoadTime).toBeLessThan(PERFORMANCE_THRESHOLDS.loadTime);\n      \n      console.log('Performance consistency analysis:', {\n        avgLoadTime,\n        maxDeviation,\n        runs: performanceMetrics\n      });\n    });\n  });\n});