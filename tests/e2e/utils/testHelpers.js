import { expect } from '@playwright/test';\nimport { PERFORMANCE_THRESHOLDS, TEST_TIMEOUTS } from '../fixtures/testData.js';\n\n/**\n * Utility functions for LokDarpan E2E tests\n * Provides reusable test helpers and validation functions\n */\n\n/**\n * Wait for network requests to complete and page to stabilize\n */\nexport async function waitForPageStability(page, options = {}) {\n  const { timeout = TEST_TIMEOUTS.medium, waitForNetworkIdle = true } = options;\n  \n  if (waitForNetworkIdle) {\n    await page.waitForLoadState('networkidle', { timeout });\n  }\n  \n  // Additional stability wait\n  await page.waitForTimeout(1000);\n}\n\n/**\n * Validate that no JavaScript errors occurred during test\n */\nexport async function validateNoJSErrors(page, allowedErrors = []) {\n  const errors = [];\n  \n  page.on('console', msg => {\n    if (msg.type() === 'error') {\n      const errorText = msg.text();\n      const isAllowed = allowedErrors.some(allowed => errorText.includes(allowed));\n      if (!isAllowed) {\n        errors.push(errorText);\n      }\n    }\n  });\n  \n  page.on('pageerror', error => {\n    errors.push(error.message);\n  });\n  \n  return errors;\n}\n\n/**\n * Take a full page screenshot with timestamp\n */\nexport async function capturePageScreenshot(page, testInfo, suffix = '') {\n  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n  const filename = `${testInfo.title.replace(/\\s+/g, '-')}-${timestamp}${suffix}.png`;\n  \n  await page.screenshot({\n    path: `./test-results/screenshots/${filename}`,\n    fullPage: true\n  });\n  \n  return filename;\n}\n\n/**\n * Measure Core Web Vitals performance metrics\n */\nexport async function measureWebVitals(page) {\n  const webVitals = await page.evaluate(() => {\n    return new Promise((resolve) => {\n      const vitals = {};\n      \n      // Largest Contentful Paint\n      const lcpObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        if (entries.length > 0) {\n          vitals.lcp = entries[entries.length - 1].startTime;\n        }\n      });\n      lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });\n      \n      // First Contentful Paint\n      const paintEntries = performance.getEntriesByType('paint');\n      const fcp = paintEntries.find(entry => entry.name === 'first-contentful-paint');\n      if (fcp) vitals.fcp = fcp.startTime;\n      \n      // Cumulative Layout Shift\n      let cls = 0;\n      const clsObserver = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          if (!entry.hadRecentInput) {\n            cls += entry.value;\n          }\n        }\n        vitals.cls = cls;\n      });\n      clsObserver.observe({ entryTypes: ['layout-shift'] });\n      \n      // First Input Delay measurement setup\n      const fidObserver = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          vitals.fid = entry.processingStart - entry.startTime;\n          break;\n        }\n      });\n      fidObserver.observe({ entryTypes: ['first-input'] });\n      \n      // Return vitals after a delay to capture metrics\n      setTimeout(() => resolve(vitals), 3000);\n    });\n  });\n  \n  return webVitals;\n}\n\n/**\n * Validate performance against thresholds\n */\nexport function validatePerformance(metrics, customThresholds = {}) {\n  const thresholds = { ...PERFORMANCE_THRESHOLDS, ...customThresholds };\n  const violations = [];\n  \n  if (metrics.fcp && metrics.fcp > thresholds.fcp) {\n    violations.push(`FCP: ${metrics.fcp}ms exceeds threshold of ${thresholds.fcp}ms`);\n  }\n  \n  if (metrics.lcp && metrics.lcp > thresholds.lcp) {\n    violations.push(`LCP: ${metrics.lcp}ms exceeds threshold of ${thresholds.lcp}ms`);\n  }\n  \n  if (metrics.cls && metrics.cls > thresholds.cls) {\n    violations.push(`CLS: ${metrics.cls} exceeds threshold of ${thresholds.cls}`);\n  }\n  \n  if (metrics.fid && metrics.fid > thresholds.fid) {\n    violations.push(`FID: ${metrics.fid}ms exceeds threshold of ${thresholds.fid}ms`);\n  }\n  \n  return { passed: violations.length === 0, violations, metrics };\n}\n\n/**\n * Simulate network conditions for performance testing\n */\nexport async function setNetworkConditions(page, conditions) {\n  const cdpSession = await page.context().newCDPSession(page);\n  \n  const networkConditions = {\n    slow3g: {\n      downloadThroughput: 500 * 1024 / 8,\n      uploadThroughput: 500 * 1024 / 8,\n      latency: 400\n    },\n    fast3g: {\n      downloadThroughput: 1.6 * 1024 * 1024 / 8,\n      uploadThroughput: 750 * 1024 / 8,\n      latency: 150\n    },\n    offline: {\n      downloadThroughput: 0,\n      uploadThroughput: 0,\n      latency: 0\n    }\n  };\n  \n  const condition = networkConditions[conditions] || conditions;\n  \n  await cdpSession.send('Network.emulateNetworkConditions', {\n    offline: condition.downloadThroughput === 0,\n    downloadThroughput: condition.downloadThroughput,\n    uploadThroughput: condition.uploadThroughput,\n    latency: condition.latency\n  });\n}\n\n/**\n * Mock API responses for testing\n */\nexport async function mockApiResponse(page, endpoint, response, options = {}) {\n  const { method = 'GET', status = 200, delay = 0 } = options;\n  \n  await page.route(`**${endpoint}`, async (route) => {\n    if (delay > 0) {\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n    \n    await route.fulfill({\n      status,\n      contentType: 'application/json',\n      body: JSON.stringify(response)\n    });\n  });\n}\n\n/**\n * Validate accessibility features\n */\nexport async function validateAccessibility(page, options = {}) {\n  const { checkColorContrast = true, checkKeyboardNav = true } = options;\n  const violations = [];\n  \n  // Check for proper heading hierarchy\n  const headings = await page.locator('h1, h2, h3, h4, h5, h6').all();\n  let lastLevel = 0;\n  \n  for (const heading of headings) {\n    const tagName = await heading.evaluate(el => el.tagName.toLowerCase());\n    const level = parseInt(tagName.slice(1));\n    \n    if (level > lastLevel + 1) {\n      violations.push(`Heading level jump from h${lastLevel} to h${level}`);\n    }\n    lastLevel = level;\n  }\n  \n  // Check for alt text on images\n  const images = await page.locator('img').all();\n  for (const img of images) {\n    const alt = await img.getAttribute('alt');\n    const src = await img.getAttribute('src');\n    \n    if (!alt && !src?.includes('data:image')) {\n      violations.push('Image missing alt text');\n    }\n  }\n  \n  // Check for form labels\n  const inputs = await page.locator('input[type=\"text\"], input[type=\"email\"], input[type=\"password\"], textarea').all();\n  for (const input of inputs) {\n    const id = await input.getAttribute('id');\n    const ariaLabel = await input.getAttribute('aria-label');\n    const ariaLabelledby = await input.getAttribute('aria-labelledby');\n    \n    if (id) {\n      const label = await page.locator(`label[for=\"${id}\"]`).count();\n      if (label === 0 && !ariaLabel && !ariaLabelledby) {\n        violations.push('Form input missing label');\n      }\n    }\n  }\n  \n  return { passed: violations.length === 0, violations };\n}\n\n/**\n * Test keyboard navigation functionality\n */\nexport async function testKeyboardNavigation(page, startElement, expectedOrder = []) {\n  await startElement.focus();\n  const focusOrder = [];\n  \n  for (let i = 0; i < 20; i++) { // Max 20 tab stops\n    const focused = await page.evaluate(() => document.activeElement?.tagName || '');\n    const focusedText = await page.evaluate(() => {\n      const el = document.activeElement;\n      return el?.textContent?.trim() || el?.getAttribute('aria-label') || el?.tagName || '';\n    });\n    \n    focusOrder.push({ element: focused, text: focusedText });\n    \n    await page.keyboard.press('Tab');\n    \n    // Check if we've cycled back to start\n    const newFocused = await page.evaluate(() => document.activeElement?.tagName || '');\n    if (newFocused === focused && i > 5) break;\n  }\n  \n  return focusOrder;\n}\n\n/**\n * Validate responsive design at different breakpoints\n */\nexport async function validateResponsiveDesign(page, breakpoints, validator) {\n  const results = {};\n  \n  for (const [name, size] of Object.entries(breakpoints)) {\n    await page.setViewportSize(size);\n    await page.waitForTimeout(500); // Allow layout to adjust\n    \n    try {\n      const isValid = await validator(page, size);\n      results[name] = { passed: isValid, viewport: size };\n    } catch (error) {\n      results[name] = { passed: false, error: error.message, viewport: size };\n    }\n  }\n  \n  return results;\n}\n\n/**\n * Generate test report data\n */\nexport function generateTestReport(testResults, performance = {}, accessibility = {}) {\n  return {\n    timestamp: new Date().toISOString(),\n    summary: {\n      totalTests: testResults.length,\n      passed: testResults.filter(t => t.passed).length,\n      failed: testResults.filter(t => !t.passed).length,\n      duration: testResults.reduce((sum, t) => sum + (t.duration || 0), 0)\n    },\n    performance: {\n      ...performance,\n      passed: performance.violations?.length === 0\n    },\n    accessibility: {\n      ...accessibility,\n      passed: accessibility.violations?.length === 0\n    },\n    tests: testResults\n  };\n}\n\n/**\n * Wait for charts/visualizations to load\n */\nexport async function waitForChartsToLoad(page, timeout = TEST_TIMEOUTS.medium) {\n  // Wait for canvas or SVG elements to appear\n  await page.waitForSelector('canvas, svg', { timeout });\n  \n  // Additional wait for chart rendering\n  await page.waitForTimeout(2000);\n  \n  // Verify charts have content\n  const chartElements = await page.locator('canvas, svg').all();\n  const renderedCharts = [];\n  \n  for (const chart of chartElements) {\n    const boundingBox = await chart.boundingBox();\n    if (boundingBox && boundingBox.width > 50 && boundingBox.height > 50) {\n      renderedCharts.push(chart);\n    }\n  }\n  \n  return renderedCharts.length;\n}\n\n/**\n * Simulate user interactions with realistic delays\n */\nexport async function simulateHumanInteraction(page, actions) {\n  for (const action of actions) {\n    // Add human-like delay between actions\n    await page.waitForTimeout(Math.random() * 500 + 300);\n    \n    switch (action.type) {\n      case 'click':\n        await page.locator(action.selector).click();\n        break;\n      case 'type':\n        await page.locator(action.selector).type(action.text, { delay: 50 + Math.random() * 100 });\n        break;\n      case 'select':\n        await page.locator(action.selector).selectOption(action.value);\n        break;\n      case 'hover':\n        await page.locator(action.selector).hover();\n        break;\n    }\n    \n    if (action.waitForResponse) {\n      await waitForPageStability(page);\n    }\n  }\n}